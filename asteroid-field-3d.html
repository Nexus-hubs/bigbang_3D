<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Asteroid Field</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000000 100%);
            position: relative;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            max-width: 400px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #ffffff;
            font-size: 14px;
            line-height: 1.6;
            transition: opacity 0.3s ease;
        }

        #info-panel.hidden {
            display: none;
        }

        #info-panel h2 {
            margin: 0 0 12px 0;
            font-size: 18px;
            font-weight: 600;
            color: #ff6b35;
        }

        #info-panel p {
            margin: 0 0 8px 0;
            opacity: 0.9;
        }

        .info-details {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 12px;
        }

        .info-details div {
            margin-bottom: 6px;
        }

        .info-details span {
            color: #ff6b35;
        }

        #close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            font-size: 20px;
            padding: 5px;
            line-height: 1;
        }

        #close-btn:hover {
            color: rgba(255, 255, 255, 1);
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            white-space: nowrap;
        }

        #toggle-info-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 107, 53, 0.2);
            border: 1px solid rgba(255, 107, 53, 0.4);
            color: #ff6b35;
            cursor: pointer;
            font-size: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        #toggle-info-btn.visible {
            display: flex;
        }

        #toggle-info-btn:hover {
            background: rgba(255, 107, 53, 0.3);
            transform: scale(1.1);
        }

        #audio-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 107, 53, 0.2);
            border: 1px solid rgba(255, 107, 53, 0.4);
            color: #ff6b35;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        #audio-toggle:hover {
            background: rgba(255, 107, 53, 0.3);
            transform: scale(1.1);
        }

        #audio-toggle.muted {
            opacity: 0.5;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b35;
            font-size: 14px;
        }

        #loading.hidden {
            display: none;
        }

        #collision-counter {
            position: absolute;
            top: 20px;
            right: 80px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            color: #ff6b35;
            font-size: 14px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Initializing Asteroid Field...</div>

        <div id="info-panel">
            <h2>Asteroid Field</h2>
            <p>Navigate through a dynamic 3D asteroid field with realistic physics and cosmic collision sounds.</p>
            <div class="info-details">
                <div><span>â€¢</span> Asteroids drift through space with varied sizes and rotation</div>
                <div><span>â€¢</span> Cosmic popping sounds when asteroids collide</div>
                <div><span>â€¢</span> Interactive camera controls for exploration</div>
                <div><span>â€¢</span> Click/tap asteroids to interact</div>
            </div>
            <button id="close-btn">Ã—</button>
        </div>

        <div id="controls-hint">Move cursor / Touch to rotate â€¢ Scroll / Pinch to zoom â€¢ Click asteroids</div>

        <button id="toggle-info-btn">i</button>
        <button id="audio-toggle">ðŸ”Š</button>
        <div id="collision-counter">Collisions: 0</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById('container');
        const infoPanel = document.getElementById('info-panel');
        const toggleBtn = document.getElementById('toggle-info-btn');
        const closeBtn = document.getElementById('close-btn');
        const loading = document.getElementById('loading');
        const audioToggle = document.getElementById('audio-toggle');
        const collisionCounter = document.getElementById('collision-counter');

        // Audio setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioEnabled = true;
        let collisionCount = 0;

        // Create cosmic popping sound
        function playCosmicPop(intensity = 1.0, frequency = 200) {
            if (!audioEnabled) return;

            const now = audioContext.currentTime;

            // Main pop oscillator
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            // Random cosmic frequency with some variation
            const baseFreq = frequency + (Math.random() * 100 - 50);
            oscillator.frequency.setValueAtTime(baseFreq, now);
            oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 0.3, now + 0.1);

            // Filter for cosmic effect
            filter.type = 'bandpass';
            filter.frequency.value = baseFreq * 2;
            filter.Q.value = 10;

            // Volume envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.3 * intensity, now + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

            oscillator.type = 'sine';
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start(now);
            oscillator.stop(now + 0.15);

            // Add subtle white noise burst for texture
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) {
                noiseData[i] = (Math.random() * 2 - 1) * 0.1;
            }

            const noiseSource = audioContext.createBufferSource();
            const noiseGain = audioContext.createGain();
            noiseSource.buffer = noiseBuffer;
            noiseGain.gain.setValueAtTime(0.2 * intensity, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

            noiseSource.connect(noiseGain);
            noiseGain.connect(audioContext.destination);
            noiseSource.start(now);
        }

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        camera.position.set(0, 10, 30);
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(20, 20, 20);
        scene.add(pointLight);

        const pointLight2 = new THREE.PointLight(0xff6b35, 0.5, 100);
        pointLight2.position.set(-20, -10, 15);
        scene.add(pointLight2);

        // Background stars
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(5000 * 3);
        for (let i = 0; i < 5000; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 300;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 300;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 300;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.2,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Asteroid field
        const asteroids = [];
        const asteroidCount = 80;

        function createAsteroidGeometry() {
            const geometry = new THREE.IcosahedronGeometry(1, 0);
            const positions = geometry.attributes.position.array;

            // Deform to make irregular shape
            for (let i = 0; i < positions.length; i += 3) {
                const noise = 0.3 + Math.random() * 0.4;
                positions[i] *= noise;
                positions[i + 1] *= noise;
                positions[i + 2] *= noise;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            return geometry;
        }

        // Create asteroids
        for (let i = 0; i < asteroidCount; i++) {
            const geometry = createAsteroidGeometry();
            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(0.1 + Math.random() * 0.1, 0.3, 0.3 + Math.random() * 0.2),
                flatShading: true,
                shininess: 5
            });

            const asteroid = new THREE.Mesh(geometry, material);

            // Random size
            const size = 0.5 + Math.random() * 2;
            asteroid.scale.set(size, size, size);

            // Random position in a spherical field
            const radius = 20 + Math.random() * 40;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            asteroid.position.x = radius * Math.sin(phi) * Math.cos(theta);
            asteroid.position.y = radius * Math.sin(phi) * Math.sin(theta);
            asteroid.position.z = radius * Math.cos(phi);

            // Random rotation
            asteroid.rotation.x = Math.random() * Math.PI * 2;
            asteroid.rotation.y = Math.random() * Math.PI * 2;
            asteroid.rotation.z = Math.random() * Math.PI * 2;

            // Random velocities
            asteroid.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02
            );

            asteroid.userData.rotationVelocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02
            );

            asteroid.userData.size = size;
            asteroid.userData.lastCollisionTime = 0;

            scene.add(asteroid);
            asteroids.push(asteroid);
        }

        // Raycaster for click detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onAsteroidClick(event) {
            event.preventDefault();

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(asteroids);

            if (intersects.length > 0) {
                const asteroid = intersects[0].object;

                // Apply impulse
                const impulse = new THREE.Vector3()
                    .copy(intersects[0].point)
                    .sub(asteroid.position)
                    .normalize()
                    .multiplyScalar(0.5);
                asteroid.userData.velocity.add(impulse);

                // Play sound
                playCosmicPop(1.0, 150 + Math.random() * 200);

                // Visual feedback
                asteroid.material.emissive = new THREE.Color(0xff6b35);
                setTimeout(() => {
                    asteroid.material.emissive = new THREE.Color(0x000000);
                }, 200);
            }
        }

        window.addEventListener('click', onAsteroidClick);

        // Interaction variables
        let mouseX = 0;
        let mouseY = 0;
        let currentZoom = 30;
        const minZoom = 10;
        const maxZoom = 80;

        // Mouse move
        window.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // Touch move
        window.addEventListener('touchmove', (event) => {
            if (event.touches.length === 1) {
                mouseX = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        });

        // Mouse wheel zoom
        window.addEventListener('wheel', (event) => {
            event.preventDefault();
            const delta = event.deltaY * 0.05;
            currentZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + delta));
        }, { passive: false });

        // Touch pinch zoom
        let lastTouchDistance = 0;
        window.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        window.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (lastTouchDistance > 0) {
                    const delta = (lastTouchDistance - distance) * 0.1;
                    currentZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + delta));
                }

                lastTouchDistance = distance;
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            lastTouchDistance = 0;
        });

        // UI controls
        closeBtn.addEventListener('click', () => {
            infoPanel.classList.add('hidden');
            toggleBtn.classList.add('visible');
        });

        toggleBtn.addEventListener('click', () => {
            infoPanel.classList.remove('hidden');
            toggleBtn.classList.remove('visible');
        });

        audioToggle.addEventListener('click', () => {
            audioEnabled = !audioEnabled;
            audioToggle.textContent = audioEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
            audioToggle.classList.toggle('muted');
        });

        // Collision detection
        function checkCollisions() {
            for (let i = 0; i < asteroids.length; i++) {
                for (let j = i + 1; j < asteroids.length; j++) {
                    const a1 = asteroids[i];
                    const a2 = asteroids[j];

                    const distance = a1.position.distanceTo(a2.position);
                    const minDistance = (a1.userData.size + a2.userData.size) * 0.8;

                    if (distance < minDistance) {
                        const now = Date.now();
                        // Prevent sound spam
                        if (now - a1.userData.lastCollisionTime > 500 &&
                            now - a2.userData.lastCollisionTime > 500) {

                            // Calculate collision intensity
                            const relativeVelocity = a1.userData.velocity.clone().sub(a2.userData.velocity);
                            const intensity = Math.min(relativeVelocity.length() * 2, 1);

                            if (intensity > 0.05) {
                                playCosmicPop(intensity, 100 + Math.random() * 300);

                                collisionCount++;
                                collisionCounter.textContent = `Collisions: ${collisionCount}`;

                                a1.userData.lastCollisionTime = now;
                                a2.userData.lastCollisionTime = now;
                            }
                        }

                        // Simple elastic collision
                        const normal = new THREE.Vector3().subVectors(a2.position, a1.position).normalize();
                        const relativeVel = new THREE.Vector3().subVectors(a1.userData.velocity, a2.userData.velocity);
                        const impulse = normal.multiplyScalar(relativeVel.dot(normal));

                        a1.userData.velocity.sub(impulse);
                        a2.userData.velocity.add(impulse);

                        // Separate asteroids
                        const separation = (minDistance - distance) / 2;
                        const separationVec = new THREE.Vector3()
                            .subVectors(a1.position, a2.position)
                            .normalize()
                            .multiplyScalar(separation);
                        a1.position.add(separationVec);
                        a2.position.sub(separationVec);
                    }
                }
            }
        }

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Update asteroids
            asteroids.forEach(asteroid => {
                // Apply velocity
                asteroid.position.add(asteroid.userData.velocity);

                // Apply rotation
                asteroid.rotation.x += asteroid.userData.rotationVelocity.x;
                asteroid.rotation.y += asteroid.userData.rotationVelocity.y;
                asteroid.rotation.z += asteroid.userData.rotationVelocity.z;

                // Boundary wrapping (keep asteroids in field)
                const maxDistance = 70;
                if (asteroid.position.length() > maxDistance) {
                    asteroid.position.multiplyScalar(-0.9);
                }

                // Slight damping
                asteroid.userData.velocity.multiplyScalar(0.999);
            });

            // Check for collisions
            if (Math.random() < 0.3) { // Don't check every frame for performance
                checkCollisions();
            }

            // Camera rotation based on mouse/touch
            const targetRotationX = mouseY * 0.5;
            const targetRotationY = mouseX * Math.PI;

            const cameraRadius = currentZoom;
            const newX = Math.sin(targetRotationY) * Math.cos(targetRotationX) * cameraRadius;
            const newY = Math.sin(targetRotationX) * cameraRadius;
            const newZ = Math.cos(targetRotationY) * Math.cos(targetRotationX) * cameraRadius;

            camera.position.x += (newX - camera.position.x) * 0.05;
            camera.position.y += (newY - camera.position.y) * 0.05;
            camera.position.z += (newZ - camera.position.z) * 0.05;

            camera.lookAt(0, 0, 0);

            // Gentle star rotation
            stars.rotation.y += 0.0002;

            renderer.render(scene, camera);
        }

        animate();
        loading.classList.add('hidden');

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Random ambient pops
        setInterval(() => {
            if (Math.random() < 0.1 && audioEnabled) {
                playCosmicPop(0.2 + Math.random() * 0.3, 80 + Math.random() * 400);
            }
        }, 3000);
    </script>
</body>
</html>
