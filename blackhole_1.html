<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interactive Black Hole</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000000 100%);
            position: relative;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            max-width: 400px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #ffffff;
            font-size: 14px;
            line-height: 1.6;
            transition: opacity 0.3s ease;
        }
        
        #info-panel.hidden {
            display: none;
        }
        
        #info-panel h2 {
            margin: 0 0 12px 0;
            font-size: 18px;
            font-weight: 600;
            color: #00B5C9;
        }
        
        #info-panel p {
            margin: 0 0 8px 0;
            opacity: 0.9;
        }
        
        .info-details {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 12px;
        }
        
        .info-details div {
            margin-bottom: 6px;
        }
        
        .info-details span {
            color: #00B5C9;
        }
        
        #close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            font-size: 20px;
            padding: 5px;
            line-height: 1;
        }
        
        #close-btn:hover {
            color: rgba(255, 255, 255, 1);
        }
        
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            white-space: nowrap;
        }
        
        #toggle-info-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 181, 201, 0.2);
            border: 1px solid rgba(0, 181, 201, 0.4);
            color: #00B5C9;
            cursor: pointer;
            font-size: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        #toggle-info-btn.visible {
            display: flex;
        }
        
        #toggle-info-btn:hover {
            background: rgba(0, 181, 201, 0.3);
            transform: scale(1.1);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00B5C9;
            font-size: 14px;
        }
        
        #loading.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Initializing...</div>
        
        <div id="info-panel">
            <h2>Black Hole</h2>
            <p>A region of spacetime where gravity is so strong that nothing, not even light, can escape.</p>
            <div class="info-details">
                <div><span>•</span> Event Horizon: Point of no return</div>
                <div><span>•</span> Accretion Disk: Superheated matter spiraling inward</div>
                <div><span>•</span> Gravitational Lensing: Light bending around the black hole</div>
            </div>
            <button id="close-btn">×</button>
        </div>
        
        <div id="controls-hint">Move cursor / Touch to rotate • Scroll / Pinch to zoom</div>
        
        <button id="toggle-info-btn">i</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById('container');
        const infoPanel = document.getElementById('info-panel');
        const toggleBtn = document.getElementById('toggle-info-btn');
        const closeBtn = document.getElementById('close-btn');
        const loading = document.getElementById('loading');

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        camera.position.z = 15;
        camera.position.y = 3;

        // Zoom controls
        let currentZoom = 15;
        const minZoom = 5;
        const maxZoom = 40;

        // Black hole (event horizon)
        const eventHorizonGeometry = new THREE.SphereGeometry(2, 64, 64);
        const eventHorizonMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vPosition;
                void main() {
                    vUv = uv;
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                void main() {
                    vec3 color = vec3(0.0);
                    float intensity = 0.05 + 0.02 * sin(time * 0.5 + vUv.y * 10.0);
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            side: THREE.DoubleSide
        });
        const eventHorizon = new THREE.Mesh(eventHorizonGeometry, eventHorizonMaterial);
        scene.add(eventHorizon);

        // Accretion disk
        const diskParticles = new THREE.Group();
        const particleCount = 8000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 2.5 + Math.random() * 6;
            const height = (Math.random() - 0.5) * 0.3 * (1 - (radius - 2.5) / 6);
            
            positions[i * 3] = Math.cos(angle) * radius;
            positions[i * 3 + 1] = height;
            positions[i * 3 + 2] = Math.sin(angle) * radius;
            
            const t = (radius - 2.5) / 6;
            colors[i * 3] = 0.8 + t * 0.2;
            colors[i * 3 + 1] = 0.6 - t * 0.3;
            colors[i * 3 + 2] = 0.4 - t * 0.4;
            
            sizes[i] = Math.random() * 0.08 + 0.02;
        }
        
        const diskGeometry = new THREE.BufferGeometry();
        diskGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        diskGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        diskGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const diskMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                varying float vIntensity;
                uniform float time;
                
                void main() {
                    vColor = color;
                    vec3 pos = position;
                    
                    float radius = length(pos.xz);
                    float angle = atan(pos.z, pos.x);
                    float speed = 1.0 / (radius * 0.5);
                    angle += time * speed;
                    
                    pos.x = cos(angle) * radius;
                    pos.z = sin(angle) * radius;
                    
                    vIntensity = 1.0 / (radius * 0.3);
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = size * 300.0 / -mvPosition.z;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vIntensity;
                
                void main() {
                    vec2 center = gl_PointCoord - 0.5;
                    float dist = length(center);
                    if (dist > 0.5) discard;
                    
                    float alpha = 1.0 - (dist / 0.5);
                    alpha = pow(alpha, 2.0);
                    
                    vec3 finalColor = vColor * (1.0 + vIntensity * 0.5);
                    gl_FragColor = vec4(finalColor, alpha * 0.8);
                }
            `,
            transparent: true,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        const diskPoints = new THREE.Points(diskGeometry, diskMaterial);
        diskParticles.add(diskPoints);
        scene.add(diskParticles);

        // Photon sphere glow
        const glowGeometry = new THREE.SphereGeometry(3, 32, 32);
        const glowMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                uniform float time;
                
                void main() {
                    float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    vec3 glow = vec3(0.6, 0.4, 0.2) * intensity;
                    float pulse = 0.8 + 0.2 * sin(time);
                    gl_FragColor = vec4(glow * pulse, intensity * 0.3);
                }
            `,
            transparent: true,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending
        });
        const photonSphere = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(photonSphere);

        // Background stars
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(3000 * 3);
        for (let i = 0; i < 3000; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 200;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 200;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Interaction variables
        let mouseX = 0;
        let mouseY = 0;

        // Mouse move
        window.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // Touch move
        window.addEventListener('touchmove', (event) => {
            if (event.touches.length === 1) {
                mouseX = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        });

        // Mouse wheel zoom
        window.addEventListener('wheel', (event) => {
            event.preventDefault();
            const delta = event.deltaY * 0.01;
            currentZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + delta));
        }, { passive: false });

        // Touch pinch zoom
        let lastTouchDistance = 0;
        window.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        window.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (lastTouchDistance > 0) {
                    const delta = (lastTouchDistance - distance) * 0.05;
                    currentZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + delta));
                }
                
                lastTouchDistance = distance;
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            lastTouchDistance = 0;
        });

        // UI controls
        closeBtn.addEventListener('click', () => {
            infoPanel.classList.add('hidden');
            toggleBtn.classList.add('visible');
        });

        toggleBtn.addEventListener('click', () => {
            infoPanel.classList.remove('hidden');
            toggleBtn.classList.remove('visible');
        });

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Update shader uniforms
            eventHorizonMaterial.uniforms.time.value = time;
            diskMaterial.uniforms.time.value = time;
            glowMaterial.uniforms.time.value = time;

            // Camera rotation based on mouse/touch
            const targetRotationX = mouseY * 0.3;
            const targetRotationY = mouseX * 0.5;
            
            camera.position.x += (targetRotationY * 20 - camera.position.x) * 0.05;
            camera.position.y += (targetRotationX * 10 + 3 - camera.position.y) * 0.05;
            
            // Apply zoom
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const distance = camera.position.length();
            camera.position.lerp(direction.multiplyScalar(-currentZoom), 0.1);
            
            camera.lookAt(scene.position);

            // Subtle disk tilt animation
            diskParticles.rotation.x = Math.sin(time * 0.1) * 0.1;

            renderer.render(scene, camera);
        }

        animate();
        loading.classList.add('hidden');

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
